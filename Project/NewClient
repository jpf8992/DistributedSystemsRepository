#####################################################
#Client Proxy
class Proxy  
  def run port
    begin
	  @server = TCPServer.open('localhost', port )
	  puts "Client Proxy Server Started with port #{port}"
	  cache = Hash.new
	  cache_time = Time.new
	  client_ID = 999
	  
      loop{	#Loop until client disconnects (e.g. a system shut-down)
			
			#Ask user to input their request for further processing
			user_request = gen_request 
			puts "User Input Specified: #{user_request}\n"
						
			#Handle Request as long as its valid!
			if !(user_request.include?"INVALID")
				puts "######################Start Session###############################"
				puts "\nHandling Request"
				dir_socket = TCPSocket.open('localhost',2010)   # Socket to listen on port 2010 - Default Dir Server Port
				dir_socket.puts user_request
				
				#Hanlde response from Dir server - should be location of file(if it exists) - 'INVALID' Otherwise
				dir_message = handle_request dir_socket	#pass socket into requests handler
				dir_socket.close
				puts "Dir message : #{dir_message}"	
				
				#Query the Storage Server that holds your desired file
				if !(dir_message.include?"INVALID")
					
					#determine the file the client wants to access
					filename = user_request.partition('_') [2]
					filename = filename.delete!("\n")
					file_action = user_request.partition('_')[0]
					puts "file action : #{file_action}".colorize(:light_blue)
					puts "filename: #{filename}".colorize(:light_blue)
					
					#FRESH CACHE HIT#
					if ( file_action == "READ" && !(cache.empty?) && cache.keys[0] == filename && cache_time.to_i <= File.mtime(File.join(Dir.pwd,'Server1000',cache.keys[0])).to_i )	
						
						puts "CACHE HIT :TRUE".colorize(:light_blue)
						puts "Cached File: #{cache.keys[0]}. Last Modified: #{File.mtime(File.join(Dir.pwd,'Server1000',cache.keys[0]))}".colorize(:light_blue)
						puts "Filename Sought: #{filename}".colorize(:light_blue)
						puts "Using Cache File".colorize(:light_blue)
						puts "File Conents:\n #{cache[filename]}\n".colorize(:cyan)
						
					#STALE CACHE HIT#	
					else	#stale - must query storage database directly
						puts "CACHE HIT :False".colorize(:magenta)
						
						#Connect with Storage Server
						puts "\n\n Establishing Connection with Storage Server ..."
						storage_port = dir_message[-5..-1].delete!("\n")
						puts "Server Port: #{storage_port}"
						puts "Opening Port #{storage_port}"
						storage_socket = TCPSocket.open('localhost',storage_port)
						puts "Connection to File Store is active!\n\n"
						storage_request = file_action+"_"+filename+"_"+client_ID.to_s
						puts"Storage Request: #{storage_request}\n"
						
						
						if (file_action == "READ")
							storage_socket.puts storage_request	#send "<action>_<filename>_<client_ID>" to storage server
						
							#read Storage Server response
							storage_response = storage_socket.gets
							puts "Storage Response:\n\n #{storage_response.colorize(:yellow)}\n\n"
							
							#Update cache
							cache[filename] = storage_response
							cache_time = Time.now
							
						elsif (file_action == "WRITE")
							storage_socket.puts storage_request	#send "<action>_<filename>_<client_ID>" to storage server
							storage_response = storage_socket.gets
							puts "Storage Response:\n\n #{storage_response.colorize(:red)}\n\n"
							
							#Get users input to for the specified file
							new_update = gets
							storage_socket.puts new_update
							
							#Update Cache
							cache[filename] = new_update
							cache_time = Time.now
							puts "Time File Updated: #{cache_time}"
						end
										
					puts "Socket Message Finished."
					puts "Closing connection with storage_socket..."
					storage_socket.close
					puts "Storage Socket Closed!"
					puts "########################End Session##############################\n"
					end
				else
					puts "Directory Response: No Valid File!"
					puts "#######################End Session###############################\n"
				end
			else
				puts "Request Invalid,\n Please Specify Valid Command!"
				puts "#######################End Session###############################\n"
			end
      }#.join
	# CTRL-C
    rescue Interrupt
      puts 'Got Interrupt..'
    # Ensure that we release the socket on errors
    ensure
      if @socket
        @socket.close
        puts 'Socked closed..'
      end
      puts 'Quitting.'
    end
  end
  
  def handle_request socket		#pass the socket stream
	puts "In Handle"
	message = socket.gets		#get message
    
		if message.include?"No Such File or Directory"
			puts "File Does Not Exist"
			return "INVALID"
		else
			puts "Dir Server Response: #{message}"
			return message
		end
	end
  
  #Handle user Requests and return an interpretable instruction for the proxy
  def gen_request 
	puts "\nPlease Specify Command\n"
	puts "Available Commands:\n <Read=filename>...\n<Write=filename>...\n<Close=filename>...\n<Open=filename>\n"
	puts "Specify Command:  "
	input_message = gets.downcase	#take user input from keyboard -> convert lowercase
    file = input_message.partition('=').last	#extract file from user input
    
	if input_message.include?"read"
		puts "Processing Read Request"
		message = "READ"
		
	elsif input_message.include?"write"
		puts "Processing Write Request"
		message = "WRITE"
	
	elsif input_message.include?"open"
		puts "Processing Open Request"
		message = "OPEN"
		
	elsif input_message.include?"close"
		puts "Processing Close Request"
		message = "CLOSE"	
	elsif (file=="")
		message = "INVALID"
	else
		#puts"Message cannot be interpreted!"
		message = "INVALID"
	end
	return	message+"_"+file
	
  end
  
end


#New Client
require 'socket'      # Sockets are in standard library
require 'colorize'
hostname = 'localhost'
port = 3000
#Create Client Proxy to Handle Communications
Proxy.new.run port






